-- Test Queries for DB Optimizer
-- These queries are designed to test various optimization scenarios

-- Query 1: Complex JOIN with multiple tables and aggregation
-- This query should benefit from proper indexing and join order optimization
SELECT u.username, c.name as category_name, COUNT(oi.item_id) as total_items_ordered, SUM(oi.total_price) as total_spent, AVG(r.rating) as avg_rating FROM users u JOIN orders o ON u.user_id = o.user_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE o.status = 'completed' AND o.order_date >= CURRENT_DATE - INTERVAL '30 days' AND u.user_type = 'premium' GROUP BY u.user_id, u.username, c.category_id, c.name HAVING COUNT(oi.item_id) > 5 ORDER BY total_spent DESC LIMIT 20;

-- Query 2: Subquery with window function and complex filtering
-- This query should benefit from subquery optimization and materialized views
SELECT p.name, p.price, p.stock_quantity, c.name as category, (SELECT AVG(rating) FROM reviews WHERE product_id = p.product_id) as avg_rating, ROW_NUMBER() OVER (PARTITION BY c.category_id ORDER BY p.price DESC) as price_rank, COUNT(oi.item_id) OVER (PARTITION BY p.product_id) as times_ordered FROM products p JOIN categories c ON p.category_id = c.category_id LEFT JOIN order_items oi ON p.product_id = oi.product_id WHERE p.is_available = TRUE AND p.stock_quantity > 0 AND p.price BETWEEN 50 AND 500 AND EXISTS (SELECT 1 FROM reviews r WHERE r.product_id = p.product_id AND r.rating >= 4) ORDER BY avg_rating DESC, price_rank;

-- Query 3: Time-series analysis with date range filtering
-- This query should benefit from partitioning and time-based indexing
SELECT DATE_TRUNC('day', il.created_at) as log_date, p.name as product_name, COUNT(*) as total_actions, SUM(CASE WHEN il.action_type = 'in' THEN il.quantity_change ELSE 0 END) as stock_in, SUM(CASE WHEN il.action_type = 'out' THEN ABS(il.quantity_change) ELSE 0 END) as stock_out, AVG(il.new_quantity) as avg_stock_level FROM inventory_log il JOIN products p ON il.product_id = p.product_id WHERE il.created_at >= CURRENT_DATE - INTERVAL '90 days' AND il.created_at < CURRENT_DATE AND p.category_id IN (1, 2, 3) GROUP BY DATE_TRUNC('day', il.created_at), p.product_id, p.name HAVING COUNT(*) > 10 ORDER BY log_date DESC, total_actions DESC;

-- Query 4: Text search and aggregation with multiple conditions
-- This query should benefit from full-text search indexes and query rewriting
SELECT u.first_name, u.last_name, u.email, COUNT(DISTINCT o.order_id) as total_orders, SUM(o.total_amount) as lifetime_value, MAX(o.order_date) as last_order_date, COUNT(DISTINCT r.review_id) as total_reviews, AVG(r.rating) as avg_review_rating FROM users u LEFT JOIN orders o ON u.user_id = o.user_id LEFT JOIN reviews r ON u.user_id = r.user_id WHERE u.is_active = TRUE AND (u.first_name ILIKE '%john%' OR u.last_name ILIKE '%smith%') AND u.created_at >= CURRENT_DATE - INTERVAL '1 year' AND (o.status IS NULL OR o.status != 'cancelled') GROUP BY u.user_id, u.first_name, u.last_name, u.email HAVING COUNT(DISTINCT o.order_id) > 0 AND SUM(o.total_amount) > 100 ORDER BY lifetime_value DESC LIMIT 50;

-- Query 5: Complex analytical query with multiple aggregations and CTEs
-- This query should benefit from materialized views and query optimization
WITH user_activity AS (SELECT u.user_id, u.username, u.user_type, COUNT(DISTINCT o.order_id) as order_count, SUM(o.total_amount) as total_spent, AVG(o.total_amount) as avg_order_value, COUNT(DISTINCT us.session_id) as session_count, AVG(us.pages_visited) as avg_pages_per_session FROM users u LEFT JOIN orders o ON u.user_id = o.user_id AND o.status = 'completed' LEFT JOIN user_sessions us ON u.user_id = us.user_id WHERE u.created_at >= CURRENT_DATE - INTERVAL '6 months' GROUP BY u.user_id, u.username, u.user_type), product_performance AS (SELECT p.product_id, p.name, p.price, c.name as category, COUNT(oi.item_id) as times_ordered, SUM(oi.quantity) as total_quantity_sold, SUM(oi.total_price) as total_revenue, AVG(r.rating) as avg_rating, COUNT(r.review_id) as review_count FROM products p JOIN categories c ON p.category_id = c.category_id LEFT JOIN order_items oi ON p.product_id = oi.product_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE p.is_available = TRUE GROUP BY p.product_id, p.name, p.price, c.category_id, c.name) SELECT ua.user_type, COUNT(ua.user_id) as user_count, AVG(ua.order_count) as avg_orders_per_user, AVG(ua.total_spent) as avg_lifetime_value, AVG(ua.avg_order_value) as avg_order_value, AVG(ua.session_count) as avg_sessions_per_user, AVG(ua.avg_pages_per_session) as avg_pages_per_session, COUNT(pp.product_id) as total_products, AVG(pp.times_ordered) as avg_product_orders, AVG(pp.avg_rating) as avg_product_rating FROM user_activity ua CROSS JOIN product_performance pp WHERE ua.total_spent > 0 AND pp.times_ordered > 0 GROUP BY ua.user_type ORDER BY avg_lifetime_value DESC; 
